[toc]

# 设计模式

**设计模式的思想**：

- 单一职责原则：每个类只有单一的功能。
- 迪米特法则：一个对象应当对其他对象有尽可能少的了解。
- 开闭原则：要求软件对扩展开放，对修改关闭。

**参考资料**：

- [GURU](https://refactoringguru.cn/design-patterns)
- [博客](https://lailin.xyz/post/go-design-pattern.html)
- [常见的UML图](https://blog.csdn.net/qq_35423190/article/details/125069834)

## 1 创建型

### 1.1 简单工厂模式
使用场景：实现简单，但是会有较多的if else分支，适用于改动的不频繁的方法。

### 1.2 工厂方法模式

#### 1.2.1 概念&作用

**工厂方法**是一种创建型设计模式，在父类中提供一个创建对象的方法， 允许子类决定实例化对象的类型。

当对象的创建逻辑比较复杂，不只是简单的new一下就可以，而是要组合其他类对象，做各种初始化操作的时候，我们推荐使用工厂方法模式，将复杂的创建逻辑拆分到多个工厂类中，让每个工厂类都不至于过于复杂。

#### 1.2.2 使用场景

- 当你在编写代码的过程中，如果无法预知对象确切类别及其依赖关系时，可使用工厂方法。
- 如果你希望用户能扩展你软件库或框架的内部组件，可使用工厂方法。
-  如果你希望复用现有对象来节省系统资源，而不是每次都重新创建对象，可使用工厂方法。

#### 1.2.3 比较不同

- **简单工厂/工厂方法/抽象工厂**

  - **简单工厂**描述了一个类，它拥有一个包含大量条件语句的构建方法，可根据方法的参数来选择对何种产品进行初始化并将其返回。

    ```java
    class UserFactory {
        public static function create($type) {
            switch ($type) {
                case 'user': return new User();
                case 'customer': return new Customer();
                case 'admin': return new Admin();
                default:
                    throw new Exception('传递的用户类型错误。');
            }
        }
    }
    ```

  - **工厂方法**在父类中提供一个创建对象的方法， 允许子类决定实例化对象的类型。

    ```java
    abstract class Department {
        public abstract function createEmployee($id);
    
        public function fire($id) {
            $employee = $this->createEmployee($id);
            $employee->paySalary();
            $employee->dismiss();
        }
    }
    
    class ITDepartment extends Department {
        public function createEmployee($id) {
            return new Programmer($id);
        }
    }
    
    class AccountingDepartment extends Department {
        public function createEmployee($id) {
            return new Accountant($id);
        }
    }
    ```

  - **抽象工厂**能创建一系列相关或相互依赖的对象， 而无需指定其具体类。

  >[工厂模式比较](https://refactoringguru.cn/design-patterns/factory-comparison)

- **工厂方法/模版方法**

  - 工厂方法是模版方法模式的一种特殊形式。

#### 1.2.4 模式结构

![image-20230806094516052](docs/imges/image-20230806094516052.png)

### 1.3 抽象工厂模式

#### 1.3.1 概念&作用

**抽象工厂**是一种创建型设计模式， 它能创建一系列相关的对象， 而无需指定其具体类。

#### 1.3.2 使用场景

- 如果代码需要与多个不同系列的相关产品交互， 但是由于无法提前获取相关信息， 或者出于对未来扩展性的考虑， 你不希望代码基于产品的具体类进行构建， 在这种情况下， 你可以使用抽象工厂。
- 如果你有一个基于一组抽象方法的类， 且其主要功能因此变得不明确， 那么在这种情况下可以考虑使用抽象工厂模式。

#### 1.3.3 比较不同

- **简单工厂/工厂方法/抽象工厂**
  - 详见1.2.3

- **建造者/抽象工厂**
  - **建造者**重点关注如何分步生成复杂对象；而**抽象工厂**专门用于生产一系列相关对象。

- **原型/抽象工厂**
  - **抽象工厂**通常基于一组工厂方法，但你也可以使用**原型模式**来生成这些类的方法。

#### 1.3.4 模式结构

![image-20230806113602508](docs/imges/image-20230806113602508.png)

### 1.4 建造者模式

#### 1.4.1 概念&作用

**建造者模式**是一种创建型设计模式， 使你能够分步骤创建复杂对象。 该模式允许你使用相同的创建代码生成不同类型和形式的对象。

#### 1.4.2 使用场景

- 类中的属性比较多。
- 类的属性之间有一定的依赖关系，或者是约束条件。
- 存在必选和非必选的属性。
- 希望创建不可变的对象。

#### 1.4.3 比较不同

- **建造者/工厂模式**
  - 建造者模式用于创建参数复杂的对象，工厂模式用于创建类型相关的不同对象

- **建造者/组合模式**
  - 可以在创建复杂组合模式树时使用建造者，因为这可使其构造步骤以递归的方式运行。
- **建造者/桥接模式**
  - 可以结合使用建造者和桥接模式：主管类负责抽象工作， 各种不同的建造者负责实现工作。

#### 1.4.4 模式结构

![image-20230806121032924](docs/imges/image-20230806121032924.png)

### 1.5 原型模式

#### 1.5.1 概念&作用

**原型模式**是一种创建型设计模式， 使你能够复制对象， 甚至是复杂对象， 而又无需使代码依赖它们所属的类。

**复制的实现方式**：

- 深拷贝
- 浅拷贝

#### 1.5.2 使用场景

- 对象的创建成本比较大，并且同一个类的不同对象之间差别不大（大部分字段相同）
  - 对象的创建成本大的情况
    - 对象数据需要经过复杂的计算，排序hash等。
    - 需要从rpc、网络、数据库等非常慢的io中获取。

#### 1.5.3 比较不同

- **原型/命令模式**
  - 原型可以用于保存命令模式的历史记录。
- **原型/组合/装饰模式**
  - 大量使用组合模式和装饰模式的设计通常可从对于原型的使用中获益。你可以通过该模式来复制复杂结构，而非从零开始重新构造。
- **原型/备忘录模式**
  - 有时候原型可以作为备忘录模式的一个简化版本， 其条件是你需要在历史记录中存储的对象的状态比较简单， 不需要链接其他外部资源， 或者链接可以方便地重建。
- **抽象工厂/建造者/原型模式**
  - 抽象工厂、建造者和原型都可以用单例模式来实现。

#### 1.5.4 模式结构

![image-20230806130448927](docs/imges/image-20230806130448927.png)

### 1.6 单例模式






## 1.2 结构型


## 1.3 行为型