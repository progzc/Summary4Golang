[toc]

# 设计模式

**设计模式的思想**：

- 单一职责原则：每个类只有单一的功能。
- 迪米特法则：一个对象应当对其他对象有尽可能少的了解。
- 开闭原则：要求软件对扩展开放，对修改关闭。

**参考资料**：

- [GURU](https://refactoringguru.cn/design-patterns)
- [博客](https://lailin.xyz/post/go-design-pattern.html)
- [常见的UML图](https://blog.csdn.net/qq_35423190/article/details/125069834)

## 1 创建型

### 1.1 简单工厂模式
使用场景：实现简单，但是会有较多的if else分支，适用于改的不频繁的方法。

### 1.2 工厂方法模式

**概念**：当对象的创建逻辑比较复杂，不只是简单的new一下就可以，而是要组合其他类对象，做各种初始化操作的时候，我们推荐使用工厂方法模式，将复杂的创建逻辑拆分到多个工厂类中，让每个工厂类都不至于过于复杂。

**作用**：在父类中提供一个创建对象的方法， 允许子类决定实例化对象的类型。

**使用场景**：

- 当你在编写代码的过程中，如果无法预知对象确切类别及其依赖关系时，可使用工厂方法。
- 如果你希望用户能扩展你软件库或框架的内部组件，可使用工厂方法。
-  如果你希望复用现有对象来节省系统资源，而不是每次都重新创建对象，可使用工厂方法。

**与其他模式的关系**：

- **简单工厂/工厂方法/抽象工厂**：

  - **简单工厂**描述了一个类，它拥有一个包含大量条件语句的构建方法，可根据方法的参数来选择对何种产品进行初始化并将其返回。

    ```java
    class UserFactory {
        public static function create($type) {
            switch ($type) {
                case 'user': return new User();
                case 'customer': return new Customer();
                case 'admin': return new Admin();
                default:
                    throw new Exception('传递的用户类型错误。');
            }
        }
    }
    ```

  - **工厂方法**在父类中提供一个创建对象的方法， 允许子类决定实例化对象的类型。

    ```java
    abstract class Department {
        public abstract function createEmployee($id);
    
        public function fire($id) {
            $employee = $this->createEmployee($id);
            $employee->paySalary();
            $employee->dismiss();
        }
    }
    
    class ITDepartment extends Department {
        public function createEmployee($id) {
            return new Programmer($id);
        }
    }
    
    class AccountingDepartment extends Department {
        public function createEmployee($id) {
            return new Accountant($id);
        }
    }
    ```

  - **抽象工厂**能创建一系列相关或相互依赖的对象， 而无需指定其具体类。

  >[工厂模式比较](https://refactoringguru.cn/design-patterns/factory-comparison)

- **工厂方法/模版方法模式**：

  - 工厂方法是模版方法模式的一种特殊形式。

**模式结构**：

![image-20230806094516052](docs/imges/image-20230806094516052.png)

### 1.3 抽象工厂模式

### 1.4 建造者模式

### 1.5 原型模式

### 1.6 单例模式




## 1.2 结构型


## 1.3 行为型