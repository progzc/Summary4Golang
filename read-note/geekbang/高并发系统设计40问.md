[toc]

# 高并发系统设计40问

## 开篇词

### 0 为什么你要学习高并发系统设计

收获：

- 掌握高并发系统设计的"套路"。
- 理解基本的系统设计思想，对新的知识触类旁通，举一反三。
- 突破技术的瓶颈，突破所处平台的限制，具备一个优秀架构师的资质。

## 基础篇

### 1 高并发系统：它的通用设计方法是什么？

#### 1.1 高并发系统的设计方法

- Scale-up（纵向扩展）：提升机器性能。
  - 适用于系统设计初期
- Scale-out（水平扩展）：分而治之。例如：分布式部署（扩展机器节点）、数据库一主多从、分库分表、存储分片。
  - 适用于系统并发超过了单机极限的时候，但要思考解决以下问题：
    - 单个节点故障，如何保证整体可用性？
    - 当多个节点状态需要同步时，怎么保证状态信息在不同节点的一致性？
    - 如何做到无感知的增加和删除节点？
    - ...

- 缓存：磁盘寻道（10ms级别）、千兆网卡（微秒级别）、CPU（纳秒级别）。缓存的思想遍布许多设计领域：
  - 操作系统中CPU有多级缓存
  - 文件有Pace Cache缓存
- 异步：解耦、消峰平谷
  - 为什么要使用异步？同步调用在高并发下可能会造成系统发生雪崩。

### 2 架构分层：我们为什么一定要这么做？

#### 2.1 典型的分层架构

- **MVC**：Model（数据访问层）-View（表现层）-Controller（业务逻辑层），模型-视图-控制器。
- **TCP-IP协议**：
  - 七层架构：应用层-表示层-会话层-传输层-网络层-数据链路层-物理层
  - 五层架构：应用层-传输层-网络层-数据链路层-物理层
- **Linux文件系统**：
  - 用户空间：Application
  - 内核空间：System Call Interface（SCI）、Vitual File System （VFS）、Ext3/Ext4/Btrfs、General Block Device layer、Device Driver
  - 硬件：Physical Disk

#### 2.2 分层的好处

- **简化系统设计**：让不同的人专注做某一层次的事情。
- **利于复用**：比如，我们在设计系统 A 的时候，发现某一层具有一定的通用性，那么我们可以把它抽取独立出来，在设计系统 B 的时候使用起来，这样可以减少研发周期，提升研发的效率。
- **利于横向扩展**：如果系统没有分层，当流量增加时我们需要针对整体系统来做扩展。但是，如果我们按照上面提到的三层架构将系统分层后，那么我们就可以针对具体的问题来做细致的扩展。
  - 比如说，业务逻辑里面包含有比较复杂的计算，导致 CPU 成为性能的瓶颈，那这样就可以把逻辑层单独抽取出来独立部署，然后只对逻辑层来做扩展，这相比于针对整体系统扩展所付出的代价就要小的多了。

#### 2.3 如何做系统分层

如何做系统分层：参照[阿里巴巴 Java 开发手册 v1.4.0（详尽版)](https://developer.aliyun.com/article/69327)

- Manager层（中台/通用SDK）：通用业务处理层。这一层主要有两个作用，其一，你可以将原先 Service 层的一些通用能力下沉到这一层，比如与缓存和存储交互策略，中间件的接入；其二，你也可以在这一层封装对第三方接口的调用，比如调用支付服务，调用审核服务等。

![image-20230808082912437](docs/imges/image-20230808082912437.png)

#### 2.4 分层的不足

- 增加了代码/系统复杂度
- 带来性能损耗

#### 2.5 软件设计分层思想

- **单一职责原则**：规定每个类只有单一的功能，在这里可以引申为每一层拥有单一职责，且层与层之间边界清晰。
- **迪米特法则**：原意是一个对象应当对其它对象有尽可能少的了解，在分层架构的体现是数据的交互不能跨层，只能在相邻层之间进行。
- **开闭原则**：要求软件对扩展开放，对修改关闭。它的含义其实就是将抽象层和实现层分离，抽象层是对实现层共有特征的归纳总结，不可以修改，但是具体的实现是可以无限扩展，随意替换的。

### 3 系统设计目标（一）：如何提升系统性能？

#### 3.1 高并发设计三高

- 高并发
- 高性能
- 高可用

#### 3.2 高并发系统设计目标

- **高并发**：提供系统的并发处理能力。脱离了高并发去谈高可用和高性能是没有意义的。
  - 通常使用**吞吐量**或者**同时在线用户数**来度量并发和流量
- **高性能**：提供系统的响应时间。
  - 性能优化原则
    - **不可提早优化**：要做到问题导向。
    - **遵循二八法则**：抓住主要矛盾，用 20% 的精力解决 80% 的性能问题。
    - **需要有数据支撑**：优化让响应时间减少了多少，提升了多少的吞吐量。
    - **持续不断的进行优化**
  - 性能的度量指标
    - 响应时间平均值：所有请求的响应时间数据相加，再除以总请求数。平均值对于度量性能来说只能作为一个参考。
    - 响应时间最大值：一段时间内所有请求响应时间最长的值。过于敏感。
    - **响应时间分位值**：分位值排除了偶发极慢请求对于数据的影响，能够很好地反应这段时间的性能情况，分位值越大，对于慢请求的影响就越敏感。
      - 健康系统的 99 分位值的响应时间通常需要控制在 200ms 之内，而不超过 1s 的请求占比要在 99.99% 以上
  - 高并发系统的性能优化方法：
    - 提高系统的处理核心数
    - 减少单次任务响应时间
      - CPU 密集型：选用高效的算法、线程池
        - 排查方式：Profile 工具，如Linux 的 perf、eBPF。
      - IO 密集型：包括磁盘IO和网络IO
        - 排查方式：
          - Linux工具：如网络协议栈、网卡、磁盘、文件系统、内存。
          - 监控
- **可扩展**：易于扩展的系统能在短时间内迅速完成扩容，更加平稳地承担峰值流量。

### 4 系统设计目标（二）：系统怎样做到高可用？

#### 4.1 可用性的度量

- **MTBF（Mean Time Between Failure）**：平均故障间隔。代表两次故障的间隔时间，也就是系统正常运转的平均时间。这个时间越长，系统稳定性越高。

- **MTTR（Mean Time To Repair）**：故障的平均恢复时间。也可以理解为平均故障时间。这个值越小，故障对于用户的影响越小。

- **Availability**：系统可用性。Availability = MTBF/(MTBF+MTTR)。

  - 一般我们会使用几个九来描述系统的可用性。**一般来说，我们的核心业务系统的可用性，需要达到四个九，非核心系统的可用性最多容忍到三个九。**

    ![image-20230808224322704](docs/imges/image-20230808224322704.png)



#### 4.2 高可用系统的设计思路

- 系统设计
  - **故障转移**：主备切换、路由摘除
    - 故障检测机制：通过心调
    - 涉及到分布式一致性算法：Paxos/Raft
  - **超时控制**：牺牲了少量的请求却保证了整体系统的可用性。不然会造成系统雪崩。
    - 如何设置超市时间呢：建议通过收集系统之间的调用日志，统计比如说 99% 的响应时间是怎样的，然后依据这个时间来指定超时时间。
  - **降级**：为了保证核心服务的稳定而牺牲非核心服务的做法。
    - 可以通过事先预留的开关暂时关闭一些非核心功能。
  - **限流**：通过对并发的请求进行限速来保护系统。
- 系统运维
  - **灰度发布**
  - **故障演练**
  - **混沌工程**

