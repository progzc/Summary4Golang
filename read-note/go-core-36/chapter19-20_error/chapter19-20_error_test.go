package chapter19_20_error

import "testing"

// TestError_1
// (1)error类型是一个内建的接口类型,接口中只包含一个方法Error,Error方法不接受任何参数,但是会返回一个string类型的结果
// (2)在进行错误处理的时候经常会用到卫述语句,即if err != nil {}
//
//	注意:go2设计草案里提到说对于这种error处理的多个卫术语句的简化，利用check，handler简化错误处理的代码量。
//
// (3)生成错误的方式: errors.New函数 和 fmt.Errorf函数
// (4)怎样判断一个错误值具体代表的是哪一类错误?
//
//	a.对于类型在已知范围内的一系列错误值,一般使用类型断言表达式或类型switch语句来判断
//	b.对于已有相应变量且类型相同的一系列错误值,一般直接使用判等操作来判断
//	c.对于没有相应变量且类型未知的一系列错误值,只能使用其错误信息的字符串表示形式来做判断
//
// (5)Q:请列举出你经常用到或者看到的 3 个错误类型，它们所在的错误类型体系都是怎样的？你能画出一棵树来描述它们吗？
//
//	A:略
func TestError_1(t *testing.T) {

}

// TestError_2
// (1)net.Error接口除了拥有error接口的Error方法之外，还有两个自己声明的方法:Timeout和Temporary.
//
//		a.可以把这些错误类型想象成一棵树，内建接口error就是树的根，而net.Error接口就是一个在根上延伸的第一级非叶子节点.
//		b.同时，也把这看做是一种多层分类的手段。当net包的使用者拿到一个错误值的时候，可以先判断它是否是net.Error类型的，也就是说该值是否代表了一个网络相关的错误。（本质是链式关系）
//	 总结:
//			Go语言标准库对错误的最佳实践是:用类型建立起树形结构的错误体系，用统一字段建立起可追根溯源的链式错误关联。
func TestError_2(t *testing.T) {

}
