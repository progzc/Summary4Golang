# 1《Go语言核心36讲》专栏总结
# 2 关于Go高性能编程总结
## 2.1 慎用反射
- 基本数据类型与字符串之间的转换,优先使用strconv,而不是fmt。
- 为了避免代码重复而使用反射，往往会带来性能上的损耗。
- 慎用binary.Read和binary.Write。
## 2.2 避免重复字符串到字节切片的转换
## 2.3 指定容器的容量
- 指定map容量提示。
- 指定切片容量。
## 2.4 字符串拼接方式的选择
- 行内拼接字符串推荐使用运算符+。
- 非行内拼接字符串推荐使用strings.Builder。
## 2.5 遍历[]struct{}使用下标而不是range
- 遍历[]int类型的切片，下标与range遍历性能几乎没有区别。
- 遍历[]struct{}类型的切片，下标比range遍历性能好很多。
- 遍历[]*struct类型的切片，下标与range遍历性能几乎一直。
## 2.6 使用空结构体节省内存
- 利用map+struct{}实现set集合。
- 使用chan+struct{}实现不发送数据的信道。
- 如果结构体只包含方法，不包含字段，则可以定义struct{}的别名。
## 2.7 结构体要考虑内存对齐
- 字段顺序按照字段宽度从小到大由上至下排列。
- struct{}作为结构体的字段类型放在结构体末尾需要占用额外内存，但是不在末尾无需占用内存。
## 2.8 减少逃逸，将变量限制在栈上
- 小的拷贝好过引用。
- 返回值 VS 返回指针。
- 返回值最好使用确定的类型，尽量不要使用interface{}
## 2.9 使用sync.Pool复用对象
## 2.10 关于锁
- 多使用无锁编程，即atomic包的数据结果。
- 在编程中多使用Reactor多线程模型的思想。
- 尽量减少锁竞争，如优先使用读写锁，其次才是互斥锁。
## 2.11 使用协程池
## 2.12 使用sync.Once避免重复执行
## 2.13 使用sync.Cond通知协程